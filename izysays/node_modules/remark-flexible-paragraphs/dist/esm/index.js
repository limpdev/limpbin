import { visit, EXIT } from "unist-util-visit";
import { u } from "unist-builder";
const dictionary = {
    a: "alert",
    b: "blue",
    c: "caution",
    d: "danger",
    e: "error",
    f: "framed",
    g: "green",
    h: "horizontal",
    i: "info",
    j: "jumbo",
    k: "kindle",
    l: "lokum",
    m: "menu",
    n: "note",
    o: "ordinary",
    p: "pack",
    q: "quantity",
    r: "red",
    s: "success",
    t: "tip",
    u: "unified",
    v: "verticle",
    w: "warning",
    x: "xray",
    y: "yellow",
    z: "zigzag",
    "0": "type-0",
    "1": "type-1",
    "2": "type-2",
    "3": "type-3",
    "4": "type-4",
    "5": "type-5",
    "6": "type-6",
    "7": "type-7",
    "8": "type-8",
    "9": "type-9",
};
const DEFAULT_SETTINGS = {
    dictionary,
    paragraphClassName: "flexible-paragraph",
    paragraphClassificationPrefix: "flexiparaph",
    wrapperTagName: "div",
    wrapperClassName: "flexible-paragraph-wrapper",
};
export const REGEX = /([~=])(:)?([a-z0-9]*\|?[a-z0-9]*)?(:)?>\s*/;
export const REGEX_GLOBAL = /([~=])(:)?([a-z0-9]*\|?[a-z0-9]*)?(:)?>\s*/g;
/**
 *
 * This plugin turns a paragraph into a flexible paragraph or splits it as a flexible paragraph,
 * with optional wrapper, customizable classifications and customizable alignment
 *
 * for example:
 *
 * ~> I am a flexible paragraph
 * => I am a flexible paragraph wrapped in a div
 *
 */
export const plugin = (options) => {
    const settings = Object.assign({}, DEFAULT_SETTINGS, options);
    if (options?.dictionary && Object.keys(options.dictionary).length) {
        settings.dictionary = Object.assign({}, dictionary, options.dictionary);
    }
    /**
     *
     * constracts the paragraph node
     *
     */
    const constructParagraph = (phrasingContents, classifications, alignment) => {
        const classnames = [];
        classifications.forEach((classification) => {
            classnames.push(settings.paragraphClassificationPrefix === ""
                ? `${classification}`
                : `${settings.paragraphClassificationPrefix}-${classification}`);
        });
        if (alignment) {
            classnames.push(settings.paragraphClassificationPrefix === ""
                ? `align-${alignment}`
                : `${settings.paragraphClassificationPrefix}-align-${alignment}`);
        }
        const paragraphClassName = typeof settings.paragraphClassName === "function"
            ? settings.paragraphClassName(alignment, classifications)
            : [settings.paragraphClassName, ...classnames];
        let properties;
        if (settings.paragraphProperties) {
            properties = settings.paragraphProperties(alignment, classifications);
            Object.entries(properties).forEach(([k, v]) => {
                if ((typeof v === "string" && v === "") ||
                    (Array.isArray(v) && v.length === 0)) {
                    if (properties) {
                        properties[k] = undefined;
                    }
                }
                if (k === "className")
                    delete properties?.["className"];
            });
        }
        return {
            type: "paragraph",
            children: phrasingContents,
            data: {
                hName: "p",
                hProperties: {
                    className: paragraphClassName,
                    ...(properties && { ...properties }),
                    style: alignment ? `text-align:${alignment}` : undefined,
                },
            },
        };
    };
    /**
     *
     * constracts the wrapper node
     *
     */
    const constructWrapper = (paragraph, classifications, alignment) => {
        const wrapperTagName = typeof settings.wrapperTagName === "string"
            ? settings.wrapperTagName
            : settings.wrapperTagName(alignment, classifications);
        const wrapperClassName = typeof settings.wrapperClassName === "function"
            ? settings.wrapperClassName(alignment, classifications)
            : [settings.wrapperClassName];
        let properties;
        if (settings.wrapperProperties) {
            properties = settings.wrapperProperties(alignment, classifications);
            Object.entries(properties).forEach(([k, v]) => {
                if ((typeof v === "string" && v === "") ||
                    (Array.isArray(v) && v.length === 0)) {
                    if (properties) {
                        properties[k] = undefined;
                    }
                }
                if (k === "className")
                    delete properties?.["className"];
            });
        }
        return {
            type: "wrapper",
            children: [paragraph],
            data: {
                hName: wrapperTagName,
                hProperties: {
                    className: wrapperClassName,
                    ...(properties && { ...properties }),
                },
            },
        };
    };
    /**
     *
     * checks whether the paragraph node contains a text node which has a regex match.
     *
     */
    function checkIsTarget(node) {
        let isTarget = false;
        visit(node, "text", (textNode) => {
            if (!REGEX.test(textNode.value))
                return;
            isTarget = true;
            return EXIT;
        });
        return isTarget;
    }
    /**
     *
     * returns the array with added value, handles if the array is undefined
     *
     */
    function insert(array, phrasingContent) {
        if (typeof array === "undefined") {
            array = [phrasingContent];
        }
        else {
            array.push(phrasingContent);
        }
        return array;
    }
    /**
     *
     * returns the extracted info about flexible paragraph from the match
     *
     */
    function getFlexibleNode({ marker, left, classes, right, }) {
        let _alignment;
        if (!left && !right) {
            _alignment = undefined;
        }
        else if (left && right) {
            _alignment = "justify";
        }
        else if (left) {
            _alignment = "left";
        }
        else if (right) {
            _alignment = "right";
        }
        if (classes?.includes("|")) {
            _alignment = "center";
        }
        if (classes === "|") {
            if (left && right) {
                _alignment = "justify";
            }
            else if (left) {
                _alignment = "left";
            }
            else if (right) {
                _alignment = "right";
            }
        }
        const markers = {
            "=": "wrapper",
            "~": "paragraph",
        };
        const type = markers[marker];
        const alignment = _alignment;
        const classifications = classes
            ? Array.from(classes).reduce((list, char) => {
                if (char !== "|") {
                    const name = settings.dictionary[char];
                    if (name)
                        list.push(name);
                }
                return list;
            }, [])
            : [];
        return { type, alignment, classifications };
    }
    /**
     *
     * type guard
     *
     */
    const isTextNode = (node) => {
        return "value" in node && node.type === "text";
    };
    /**
     *
     * visits the Paragraph nodes
     *
     */
    const visitor = function (node, index, parent) {
        /* v8 ignore next */
        if (!parent || typeof index === "undefined")
            return;
        const isTarget = checkIsTarget(node);
        if (!isTarget)
            return;
        const nodes = [];
        const phrasesMatrix = [[]];
        const flexibleNodes = [];
        let matrixIndex = 0;
        // traverse the paragraph looking for the markers
        for (const phrasingContent of node.children) {
            if (!isTextNode(phrasingContent)) {
                phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], phrasingContent);
            }
            else {
                const value = phrasingContent.value;
                // console.log("value: ", JSON.stringify(value));
                // console.log(Array.from(value.matchAll(REGEX_GLOBAL), (m) => m[0]));
                const matches = Array.from(value.matchAll(REGEX_GLOBAL));
                if (!matches.length) {
                    phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], phrasingContent);
                }
                else {
                    for (let idx = 0; idx < matches.length; idx++) {
                        const match = matches[idx];
                        const [matched, marker, left, classes, right] = match;
                        const mIndex = match.index;
                        const mLength = matched.length;
                        // if it is the first match but the marker index is not first
                        if (idx === 0 && mIndex !== 0) {
                            const textValue = value.substring(0, mIndex);
                            if (textValue) {
                                const text = u("text", textValue);
                                phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], text);
                            }
                        }
                        // do not increase matrixIndex if the marker is in the first phrase in the beginning
                        if (idx !== 0 || mIndex !== 0)
                            matrixIndex++;
                        const textValue = idx === matches.length - 1
                            ? // if it is the last match
                                value.slice(mIndex + mLength)
                            : // if it is NOT the last match
                                value.substring(mIndex + mLength, matches[idx + 1].index);
                        if (textValue) {
                            const text = u("text", textValue);
                            phrasesMatrix[matrixIndex] = insert(phrasesMatrix[matrixIndex], text);
                        }
                        flexibleNodes[matrixIndex] = getFlexibleNode({
                            marker, // "=" or "~"
                            left,
                            classes,
                            right,
                        });
                    }
                }
            }
        }
        // clean the newline and spaces at the last phrases (if Text) of each flexible paragraph
        phrasesMatrix.forEach((phrasingContents) => {
            const lastPhrase = phrasingContents[phrasingContents.length - 1];
            if (lastPhrase.type === "text") {
                lastPhrase.value = lastPhrase.value.replace(/[\s\r\n]+$/, "");
            }
        });
        // construct the flexible paragraphs whether in a wrapper or not
        phrasesMatrix.forEach((phrasingContents, i) => {
            const paragraph = flexibleNodes[i]
                ? constructParagraph(phrasingContents, flexibleNodes[i].classifications, flexibleNodes[i].alignment)
                : u("paragraph", phrasingContents);
            if (flexibleNodes[i]?.type === "wrapper") {
                const wrapper = constructWrapper(paragraph, flexibleNodes[i].classifications, flexibleNodes[i].alignment);
                nodes.push(wrapper);
            }
            else {
                nodes.push(paragraph);
            }
        });
        if (nodes.length)
            parent.children.splice(index, 1, ...nodes);
    };
    const transformer = (tree) => {
        visit(tree, "paragraph", visitor);
    };
    return transformer;
};
export default plugin;
//# sourceMappingURL=index.js.map
import type { Plugin } from "unified";
import type { Data, Paragraph, Parent, Root } from "mdast";
interface WrapperData extends Data {
}
interface Wrapper extends Parent {
    /**
     * Node type of mdast Mark.
     */
    type: "wrapper";
    /**
     * Children of paragraph.
     */
    children: [Paragraph];
    /**
     * Data associated with the mdast paragraph.
     */
    data?: WrapperData | undefined;
}
declare module "mdast" {
    interface RootContentMap {
        wrapper: Wrapper;
    }
}
type Alignment = "center" | "left" | "right" | "justify";
type Key = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
type Dictionary = Partial<Record<Key, string>>;
type RestrictedRecord = Record<string, unknown> & {
    className?: never;
};
type TagNameFunction = (alignment?: Alignment, classifications?: string[]) => string;
type ClassNameFunction = (alignment?: Alignment, classifications?: string[]) => string[];
type PropertyFunction = (alignment?: Alignment, classifications?: string[]) => RestrictedRecord;
export type FlexibleParagraphOptions = {
    dictionary?: Dictionary;
    paragraphClassName?: string | ClassNameFunction;
    paragraphProperties?: PropertyFunction;
    paragraphClassificationPrefix?: string;
    wrapperTagName?: string | TagNameFunction;
    wrapperClassName?: string | ClassNameFunction;
    wrapperProperties?: PropertyFunction;
};
export declare const REGEX: RegExp;
export declare const REGEX_GLOBAL: RegExp;
/**
 *
 * This plugin turns a paragraph into a flexible paragraph or splits it as a flexible paragraph,
 * with optional wrapper, customizable classifications and customizable alignment
 *
 * for example:
 *
 * ~> I am a flexible paragraph
 * => I am a flexible paragraph wrapped in a div
 *
 */
export declare const plugin: Plugin<[FlexibleParagraphOptions?], Root>;
export default plugin;

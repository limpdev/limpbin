import { fromHtmlIsomorphic } from 'hast-util-from-html-isomorphic';
import { toText } from 'hast-util-to-text';
import { createMermaidRenderer } from 'mermaid-isomorphic';
import svgToDataURI from 'mini-svg-data-uri';
import { parse } from 'space-separated-tokens';
import { visitParents } from 'unist-util-visit-parents';
/**
 * A regular expression to test for non-whitespace characters.
 */
const nonWhitespacePattern = /\w/;
const strategies = ['img-png', 'img-svg', 'inline-svg', 'pre-mermaid'];
/**
 * Validate the strategy option is valid.
 *
 * @param strategy The user provided strategy.
 * @returns The strategy if valid.
 */
function validateStrategy(strategy = 'inline-svg') {
    if (strategies.includes(strategy)) {
        return strategy;
    }
    throw new Error(`Expected strategy to be one of ${strategies.join(', ')}, got: ${strategy}`);
}
/**
 * Check if a hast element has the `language-mermaid` class name.
 *
 * @param element The hast element to check.
 * @param strategy The mermaid strategy to use.
 * @returns Whether or not the element has the `language-mermaid` class name.
 */
function isMermaidElement(element, strategy) {
    let mermaidClassName;
    if (element.tagName === 'pre') {
        if (strategy === 'pre-mermaid') {
            return false;
        }
        mermaidClassName = 'mermaid';
    }
    else if (element.tagName === 'code') {
        mermaidClassName = 'language-mermaid';
    }
    else {
        return false;
    }
    let className = element.properties?.className;
    if (typeof className === 'string') {
        className = parse(className);
    }
    if (!Array.isArray(className)) {
        return false;
    }
    return className.includes(mermaidClassName);
}
/**
 * A [rehype](https://rehype.js.org) plugin to render [mermaid](https://mermaid-js.github.io)
 * diagrams.
 *
 * @param options Options that may be used to tweak the output.
 */
const rehypeMermaid = (options) => {
    const strategy = validateStrategy(options?.strategy);
    const renderDiagrams = createMermaidRenderer(options);
    return (ast, file) => {
        const instances = [];
        visitParents(ast, 'element', (node, ancestors) => {
            if (!isMermaidElement(node, strategy)) {
                return;
            }
            const parent = ancestors.at(-1);
            let inclusiveAncestors = ancestors;
            // This is <code> wrapped in a <pre> element.
            if (parent.type === 'element' && parent.tagName === 'pre') {
                for (const child of parent.children) {
                    // We allow whitespace text siblings, but any other siblings mean we donâ€™t process the
                    // diagram.
                    if (child.type === 'text') {
                        if (nonWhitespacePattern.test(child.value)) {
                            return;
                        }
                    }
                    else if (child !== node) {
                        return;
                    }
                }
            }
            else {
                inclusiveAncestors = [...inclusiveAncestors, node];
            }
            instances.push({
                diagram: toText(node, { whitespace: 'pre' }),
                ancestors: inclusiveAncestors
            });
        });
        // Nothing to do. No need to start a browser in this case.
        if (!instances.length) {
            return;
        }
        if (strategy === 'pre-mermaid') {
            for (const { ancestors, diagram } of instances) {
                const parent = ancestors.at(-2);
                const node = ancestors.at(-1);
                parent.children[parent.children.indexOf(node)] = {
                    type: 'element',
                    tagName: 'pre',
                    properties: {
                        className: ['mermaid']
                    },
                    children: [{ type: 'text', value: diagram }]
                };
            }
            return;
        }
        return renderDiagrams(instances.map((instance) => instance.diagram), { ...options, screenshot: strategy === 'img-png' }).then((results) => {
            for (const [index, { ancestors, diagram }] of instances.entries()) {
                const node = ancestors.at(-1);
                const result = results[index];
                let replacement;
                if (result.status === 'fulfilled') {
                    const { description, height, id, screenshot, svg, title, width } = result.value;
                    if (screenshot) {
                        replacement = {
                            type: 'element',
                            tagName: 'img',
                            properties: {
                                alt: description || '',
                                height,
                                id,
                                src: `data:image/png;base64,${screenshot.toString('base64')}`,
                                title,
                                width
                            },
                            children: []
                        };
                    }
                    else if (strategy === 'inline-svg') {
                        replacement = fromHtmlIsomorphic(svg, { fragment: true }).children[0];
                    }
                    else if (strategy === 'img-svg') {
                        replacement = {
                            type: 'element',
                            tagName: 'img',
                            properties: {
                                alt: description || '',
                                height,
                                id,
                                src: svgToDataURI(svg),
                                title,
                                width
                            },
                            children: []
                        };
                    }
                }
                else if (options?.errorFallback) {
                    replacement = options.errorFallback(node, diagram, result.reason, file);
                }
                else {
                    const message = file.message(result.reason, {
                        ruleId: 'rehype-mermaidjs',
                        source: 'rehype-mermaidjs',
                        ancestors
                    });
                    message.fatal = true;
                    message.url = 'https://github.com/remcohaszing/rehype-mermaidjs';
                    throw message;
                }
                const parent = ancestors.at(-2);
                const nodeIndex = parent.children.indexOf(node);
                if (replacement) {
                    parent.children[nodeIndex] = replacement;
                }
                else {
                    parent.children.splice(nodeIndex, 1);
                }
            }
        });
    };
};
export default rehypeMermaid;

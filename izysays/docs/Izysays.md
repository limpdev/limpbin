#  Izysays 

Here is a comprehensive guide to creating the foundation for a Chrome extension that renders local ==Markdown== files using `remark` and `rehype`.

> [!NOTE]
> This foundation will include a modern JavaScript toolchain (Webpack) to bundle the necessary Node.js libraries for browser use.

### Project Goal

1.  **Detect**: The extension will activate when the user opens a local file ending in `.md` (e.g., `file:///path/to/your/document.md`).
2.  **Transform**: It will take the raw Markdown text, process it using the `remark`/`rehype` pipeline, including syntax highlighting for code blocks.
3.  **Display**: It will replace the default plain text view with a beautifully rendered HTML page inside the same tab.

### Project Structure

First, create a folder for your extension. Let's call it `Izysays`. Inside, set up the following file structure:

```bash
Izysays/
├── dist/                   // This folder will be generated by our build process
├── node_modules/           // Will be created by npm
├── public/                 // Static files that will be copied to dist/
│   ├── manifest.json
│   └── style.css
├── src/                    // Our source code
│   └── content.js
├── package.json
└── webpack.config.js
```

### Setup Dependencies & Build Tool

You'll need Node.js and npm installed... or yarn - which, if that _is_ your preference - you can skip this section since you already know what to do.

1.  **Initialize the project**:

Open your terminal in the `Izysays` directory and run:

```bash
npm init -y
```

2.  **Install dependencies**:

We need `remark`, `rehype`, and some helpful plugins.

```bash
# Core processing libraries
npm install unified remark-parse remark-rehype rehype-stringify remark-gfm rehype-highlight
```

- `unified`: The core engine that powers remark/rehype.
- `remark-parse`: Parses Markdown into a syntax tree.
- `remark-gfm`: Adds support for GitHub Flavored Markdown (tables, strikethrough, etc.).
- `remark-rehype`: Converts the Markdown tree to an HTML tree.
- `rehype-highlight`: Adds syntax highlighting to code blocks (uses `highlight.js`).
- `rehype-stringify`: Serializes the HTML tree into an HTML string.

3.  **Install development dependencies (Webpack)**:

```bash
# Build tools
npm install --save-dev webpack webpack-cli copy-webpack-plugin
```

    - `webpack` & `webpack-cli`: To bundle our JavaScript for the browser.
    - `copy-webpack-plugin`: To copy static files like `manifest.json` and `style.css` into our final `dist` folder.

### Configure the Extension and Build Process

Now, let's fill in the content of our configuration files.

#### `package.json`

Add a `build` script to your `package.json`. It should look something like this:

```json
{
    "name": "Izysays",
    "version": "1.0.0",
    "description": "Renders local Markdown files in Chrome.",
    "private": true,
    "scripts": {
        "build": "webpack --mode=production",
        "watch": "webpack --mode=development --watch"
    },
    "dependencies": {
        "rehype-highlight": "^7.0.0",
        "rehype-stringify": "^10.0.0",
        "remark-gfm": "^4.0.0",
        "remark-parse": "^11.0.0",
        "remark-rehype": "^11.1.0",
        "unified": "^11.0.4"
    },
    "devDependencies": {
        "copy-webpack-plugin": "^12.0.2",
        "webpack": "^5.91.0",
        "webpack-cli": "^5.1.4"
    }
}
```

#### `webpack.config.js`

This file tells Webpack how to bundle our code.

```javascript
const path = require("path");
const CopyPlugin = require("copy-webpack-plugin");

module.exports = {
    // Entry point for our content script
    entry: {
        content: "./src/content.js",
    },
    // Output configuration
    output: {
        path: path.resolve(__dirname, "dist"),
        filename: "[name].bundle.js",
        clean: true, // Clean the dist folder before each build
    },
    // Plugins
    plugins: [
        new CopyPlugin({
            patterns: [
                { from: "public", to: "." }, // Copies files from public/ to dist/
            ],
        }),
    ],
    // Optional: configuration for resolving modules, etc.
    resolve: {
        extensions: [".js"],
    },
};
```

#### `public/manifest.json` (Manifest V3)

This is the core configuration file for the Chrome extension.

```json
{
    "manifest_version": 3,
    "name": "Izysays",
    "version": "1.0",
    "description": "Automatically renders local Markdown files as HTML with Remark.",
    "permissions": [],
    "host_permissions": ["file://*/*"],
    "content_scripts": [
        {
            "matches": ["file://*/*.md", "file://*/*.markdown", "file://*/*.mdown"],
            "js": ["content.bundle.js"],
            "run_at": "document_start"
        }
    ],
    "web_accessible_resources": [
        {
            "resources": ["style.css"],
            "matches": ["file://*/*"]
        }
    ],
    "icons": {
        "48": "icon.png", // You'll need to create an icon.png file in /public
        "128": "icon.png"
    }
}
```

**Important Notes on `manifest.json`:**

- `host_permissions`: `file://*/*` is crucial for allowing the extension to access local files.
- `content_scripts`: This injects our script into any local file ending with `.md`, `.markdown`, or `.mdown`.
- `web_accessible_resources`: This makes `style.css` available to be injected into the page from our content script.

### Write the Extension Code

Now for the logic that does the transformation.

#### `public/style.css`

Let's add some basic styling to make the rendered HTML look good. This is a simple, GitHub-like theme. You can also add a syntax highlighting theme here.

```css
/* Import a default theme for highlight.js */
@import "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css";

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    line-height: 1.6;
    color: #24292e;
    max-width: 800px;
    margin: 40px auto;
    padding: 0 20px;
    background-color: #fff;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    border-bottom: 1px solid #eaecef;
    padding-bottom: 0.3em;
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
}

p,
blockquote,
ul,
ol,
dl,
table,
pre {
    margin-top: 0;
    margin-bottom: 16px;
}

code {
    font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
    padding: 0.2em 0.4em;
    margin: 0;
    font-size: 85%;
    background-color: rgba(27, 31, 35, 0.05);
    border-radius: 3px;
}

pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f6f8fa;
    border-radius: 3px;
}

pre code {
    padding: 0;
    margin: 0;
    background-color: transparent;
    border: 0;
}

a {
    color: #0366d6;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

table {
    border-collapse: collapse;
    width: 100%;
}
table,
th,
td {
    border: 1px solid #dfe2e5;
}
th,
td {
    padding: 6px 13px;
}

blockquote {
    padding: 0 1em;
    color: #6a737d;
    border-left: 0.25em solid #dfe2e5;
}
```

_(Don't forget to add a `icon.png` to the `public` folder for the extension icon)_.

#### `src/content.js`

This is the heart of our extension. It reads the raw Markdown, processes it, and replaces the page content.

```javascript
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkGfm from "remark-gfm";
import remarkRehype from "remark-rehype";
import rehypeHighlight from "rehype-highlight";
import rehypeStringify from "rehype-stringify";

async function renderMarkdown() {
    try {
        // More robust check for markdown content
        const preElement = document.querySelector("pre");

        if (!preElement || !preElement.textContent) {
            console.log("No markdown content found");
            return;
        }

        // Additional check to ensure we're dealing with a markdown file
        const isMarkdownFile = window.location.pathname.endsWith(".md") || window.location.pathname.endsWith(".markdown");

        if (!isMarkdownFile) {
            console.log("Not a markdown file");
            return;
        }

        // Hide the body to prevent flash of unstyled content
        document.body.style.display = "none";

        const rawMarkdown = preElement.textContent;

        // Set up the remark/rehype processor with error handling
        const processor = unified()
            .use(remarkParse) // Parse markdown
            .use(remarkGfm) // Support GFM (tables, etc.)
            .use(remarkRehype, { allowDangerousHtml: false }) // Turn markdown into HTML
            .use(rehypeHighlight) // Add syntax highlighting
            .use(rehypeStringify); // Convert HTML to string

        const file = await processor.process(rawMarkdown);
        const renderedHtml = String(file);

        // Stop the browser's default rendering
        if (window.stop) {
            window.stop();
        }

        // Get the original title or create one from the filename
        const title = document.title || window.location.pathname.split("/").pop() || "Markdown Preview";

        // Prepare the new document structure
        document.documentElement.innerHTML = `
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>${title}</title>
            </head>
            <body>
                <div id="markdown-content-container">
                    ${renderedHtml}
                </div>
            </body>
        `;

        // Inject our stylesheet with error handling
        try {
            const link = document.createElement("link");
            link.rel = "stylesheet";
            link.href = chrome.runtime.getURL("style.css");
            link.onerror = () => console.warn("Failed to load stylesheet");
            document.head.appendChild(link);
        } catch (styleError) {
            console.warn("Error loading stylesheet:", styleError);
        }

        // Reveal the body now that it's styled
        document.body.style.display = "block";
    } catch (error) {
        console.error("Error rendering markdown:", error);

        // Restore original content on error
        document.body.style.display = "block";

        // Show error message to user
        const errorDiv = document.createElement("div");
        errorDiv.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: #ff4444;
            color: white;
            padding: 10px;
            border-radius: 4px;
            z-index: 10000;
            font-family: monospace;
        `;
        errorDiv.textContent = `Markdown rendering failed: ${error.message}`;
        document.body.appendChild(errorDiv);

        // Auto-hide error after 5 seconds
        setTimeout(() => {
            if (errorDiv.parentNode) {
                errorDiv.parentNode.removeChild(errorDiv);
            }
        }, 5000);
    }
}

// Wait for DOM to be ready
if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderMarkdown);
} else {
    renderMarkdown();
}
```

---

### Build and Install the Extension

1.  **Build the extension**:
    In your terminal, run the build command:

```bash
npm run build
```

    This will create the `dist` folder, containing all the necessary files bundled and ready to be loaded by Chrome.

2.  **Install in Chrome**:

    - Open Chrome and navigate to `chrome://extensions`.
    - Enable **"Developer mode"** using the toggle in the top-right corner.
    - Click the **"Load unpacked"** button.
    - Select the `dist` folder that was generated in your project directory.

3.  **Enable File Access**:
    - After the extension is loaded, find it in your list of extensions and click **"Details"**.
    - Scroll down and enable the **"Allow access to file URLs"** toggle. **This step is mandatory** for the extension to work on local files.

### ???

### Profit
